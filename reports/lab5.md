# rCore 实验第五章

### 实践作业

tcb 中的 spawn 大部分是和 tab 的 new 方法相同，只不过对新建的子进程的父进程和当前进程的子进程向量进行了修改

### 问答作业

1. fork + exec 的一个比较大的问题是 fork 之后的内存页/文件等资源完全没有使用就废弃了，针对这一点，有什么改进策略？

   正常的是执行完 fork 系统调用之后，回到用户态，然后再执行 exec 系统调用，进入内核态，同时 fork 申请的资源没有使用就浪费了，可以直接在内核态完成 fork + exec

2. ```
   int main(){
       int val = 2;
   
       printf("%d", 0);
       int pid = fork();
       if (pid == 0) {
           val++;
           printf("%d", val);
       } else {
           val--;
           printf("%d", val);
           wait(NULL);
       }
       val++;
       printf("%d", val);
       return 0;
   }
   ```

   若 fork 之后主程序先运行，则输出为 21342（父进程输出 1 之后要等待子进程执行完，因此会切换到子进程，子进程输出 3，4，最后父进程再输出 2）

   若 fork 之后子进程先运行，则输出为 23412（子进程直接执行完毕，中间不发生进程切换）或者输出 23142（子进程输出完 3 之后切换到父进程，父进程输出 1 之后等待子进程结束）

3. ```
   int main() {
       fork() && fork() && fork() || fork() && fork() || fork() && fork();
       printf("A");
       return 0;
   }
   ```

   输出结果

   若第一个 fork 之后，子进程先运行，子进程的返回值为 0，因此会到第四个 fork，同理如果还是子进程先运行，则会到第六个 fork，若还是子进程先执行，则这一行结束，开始输出，可以通过画图来表示，每个节点向左表示父进程先运行，向右表示子进程先运行