# 参加例会
```
await 在函数中异步？？？

异步系统调用？？？

管道是攒够了带换行符的字符串，然后才送到内核
```

# rCore 实验指导书第二章节

```
第一章节实现的 LOG 等级控制还存在问题，目前没有找到错误的地方，后续学的更加全面了，再来解决。
继续第二章的实验，暂时先不使用 LOG

在 batch 初始化时打印出所有的应用程序信息 print_app_info()

通过 batch::run_next_app() 调度应用程序，这个过程涉及到特权级的转换，从 S 模式进入到 U 模式，因此，首先要实现中断

在中断处理这块，riscv 显然比 x86 要简化很多
riscv 通过 m/sstatus CSR 寄存器中的 MPP/SPP 字段知道发生异常之前的特权级
x86 是通过 cpl rpl dpl 等机制来判断发生异常之前的特权级，是否访问到非法地址等
riscv 怎么判断是否要进行中断处理？
	1. 主动使用了 ecall 或 ebreak 指令
	2. 外部设备中断，产生了中断信号
	3. 除 0 等会产生异常的操作，怎么处理？？？
riscv 通过 CSR 寄存器来完成对中断的相关处理，x86 则是利用栈来完成相关的处理。
	1. 比如riscv 有 mepc 寄存器保存返回地址等，而 x86 的返回地址则是保存在中断栈中
	2. riscv 可以直接在 mtvec 寄存器中得到中断处理函数的地址，而 x86 还需要查找中断向量表

riscv 规定进入和退出异常机制中没有硬件自动保存和恢复上下文的操作，软件需要明确地使用指令进行上下文的保存和恢复

实现 TrapContext 数据结构以及对应的方法（保存栈指针、初始化应用程序上下文）



```



