[TOC]

### 异步编程、RUST 语言和异步操作系统

#### 异步编程

##### 基本概念

- 阻塞 IO：进入内核，如果没有准备好数据，则会一直等待
- 非阻塞 IO：进入内核，若内核没有准备好数据，会返回到用户态
- IO 复用模型：进程会调用 select 系统调用，监听是否有套接字获取了数据变为可读；得到对应的套接字之后，返回用户态，在获取的套接字再重新进入内核，获取数据
- 信号驱动 IO 模型：先用系统调用 sigaction 注册一个事件，返回正常的执行流，内核之后收到数据了会向进程发送一个信号，之后进程再进入内核获取数据；类似与 A 从 B的家里回去，B 让 A 到家之后给 B 打个电话（这个过程就相当于先注册一个事件），A 到家之后给 B 回了电话，B 收到之后就开始干别的事情（进程进入内核去获取数据）
- 异步 IO 模型：类似于信号驱动 IO 模型，只不过信号机制需要进入内核两次，而异步则是进入内核之后返回到正常的流程，之后数据准备好之后发送信号给用户态（用户态中断）

##### OS Aproach

- 多任务

    - 非抢占式多任务：通过 yielded 来控制，只能自己主动放弃，否则只能等当前任务执行完，才能执行下一个，但是若当前任务存在 bug，又没有主动让出，则会导致整个系统宕机

    - 抢占式多任务：OS 来负责任务调度，能够结束当前的任务

- 在用户态实现的线程

    - 优点：不需要进入内核，上下文的切换较快、使用的栈只需要很小的空间、
    - 缺点：栈可能会增大、每次切换需要保存 CPU 的所有状态、要保证跨平台很复杂

- 内核支持的线程

    - 优点：任务切换快、并行
    - 缺点：线程进入内核需要使用栈，占用了空间、涉及到大量的系统调用

- 信号机制（用户态的异步处理机制）

    - 通过 sigaction 系统调用注册某个信号，之后会返回到用户态正常的执行流，之后若有其他的进程等向当前的进程发送了一个信号，则当下一次进程进入到内核并返回时，会进入到预先设定好的用户态中断处理函数中，在用户态中断处理函数结束会发送一个信号，让进程从内核返回时回到正常的执行流

##### Programming Aproach

- 基于回调的方法，传递需要执行的函数指针，主函数传递回调函数的函数指针，在主函数中先执行回调函数，再执行主函数，**但是主函数和回调函数是一个并行的过程，并不会因为回调函数阻塞而阻塞**
    - 优点：容易实现、没有上下文的切换、相对较低的内存开销
    - 缺点：随着回调函数数量的增加，内存开销成线性增长、回调函数会对正常的执行流中的信息进行更改，这个是不符合逻辑的，也是难以预测的，难以找到 bug
- Event queue：Epoll，Kqueue and IOCP
    - Epoll：在发生大量的事件时非常高效，epoll_create() 会在内核创建一个 epoll 实例，通过 epoll_ctl() 注册事件，通过 epoll_wait() 返回就绪的事件和数据（子集），线程注册事件之后就返回用户态，之后继续执行，等到等待的事件执行完，会发送信号给用户态线程
- io_uring：设置了共享缓冲区，减少了不必要的数据传递
    - io_uring_setup：设置上下文
    - io_uring_enter：提交并获取完成的任务
    - io_uring_register：注册内核用户共享的缓冲区

#### Rust 语言的并发和异步支持

- Rust 的并发编程
    - 安全性保证：所有权、借用、
- Rust 中的 Future
    - 调用 IO 时，系统调用立即返回，然后可以进行其他的工作
    - IO 完成时，会回到异步 IO 暂停的那个任务线上来执行
    - Executor：通过轮询来推进任务，直至任务无法取得进展
    - Reactor：注册 Future 正在等待的事件源，确保该事件就绪时能够唤醒 Future
    - Waker：唤醒 Future ，调度 Future，使得 Future 能够再次被轮询
    - Future 中的状态机转换：一个线程可以分为几个的事件，事件与事件之间可以被划分开来，因此就可以得到一些可以暂停的点
    - 对于自引用的结构，将那些信息保存在堆里面，这样在切换协程时，清空栈并不会对这些自引用的结构产生影响
- Function colors in Rust
    - 使得能够在同步的函数中调用异步的函数，在异步的函数中可以调用同步的函数


#### 异步操作系统

- Rust 语言编译器与操作系统紧密结合，优化内核的并发性能
- 向应用程序提供异步系统调用接口
    - 异步系统调用的执行过程：只会在第一次系统调用和最后一次系统调用时进入内核，第一次异步系统调用准备相应的参数，之后内核会映射一段共享内存，在共享内存的相应队列中保存服务协程的异步执行的结果，并通过用户态中断通知应用进程，之后中间的异步系统调用只会查询共享内存中的第一次系统调用的结果，最后一次系统调用，则表示服务已经完成，用户态可以继续执行
- 完善进程、线程、协程的概念以及调度机制
- 用户态中断技术

