### AsyncOS 异步操作系统

#### 多核的相关设置

1. 启动

    在 Makefile 启动 qemu 中添加 -smp n 来启动 n 个核

    ```makefile
    qemu-system-riscv64 \
    		-machine virt \
    		-m 128 \
    		-nographic \
    		-bios $(BOOTLOADER) \
    		-smp 4
    ```

    rustsbi 设置了内核的入口地址为 0x8020_0000，每个核的栈空间为 4KB，最多 8 个核

    ```rust
    mod constants {
        /// 特权软件入口。
        pub(crate) const SUPERVISOR_ENTRY: usize = 0x8020_0000;
        /// 每个核设置 16KiB 栈空间。
        pub(crate) const LEN_STACK_PER_HART: usize = 16 * 1024;
        /// qemu-virt 最多 8 核。
        pub(crate) const NUM_HART_MAX: usize = 8;
        /// SBI 软件全部栈空间容量。
        pub(crate) const LEN_STACK_SBI: usize = LEN_STACK_PER_HART * NUM_HART_MAX;
    }
    ```

    在内核的入口处先设置 tp 寄存器、各个核使用的栈，不能直接使 sp = boot_stack_top，而是根据硬件线程 hart_id 来分配空间

    ```assembly
        .section .text.entry
        .globl _start
    _start:
        # a0: hart id
        mv tp, a0
        la sp, boot_stack
        # li t1, 4096 * 16 # t1 = 4096 * 16 64KB
        addi t0, a0, 1  # t0 = a0 + 1 hartid+1
        slli t0, t0, 16 # 64K * (hartid + 1)
        add sp, sp, t0  # sp = sp + t0
        call rust_main
    
        .section .bss.stack
        .globl boot_stack
    boot_stack:
        .space 4096 * 16 * 4
        .globl boot_stack_top
    boot_stack_top:
    ```

    在内核 ·`rust_main` 函数，需要根据不同的 `hart_id` 来完成不同的工作，通过一个 `AtomicBool` 控制各个核之间的同步，当主核没有完成相关的初始化工作时，若其他核先启动，则会一直自旋，直到主核完成了初始化，同时需要对 `console.rs` 中的 `println!` 和` print!` 修改，将`stdout` 用 `Mutex` 包装起来，保证其执行的原子性，否则在打印时会比较混乱（暂时未找到 send_ipi 函数的相关文档，猜测是给其他核发送中断）

2. 各个核完成的任务

    主核：完成内存管理初始化、终端初始化、文件系统初始化等工作，之后会执行 `basic_rt::thread::init_cpu_test()`，创建回调队列、RRS调度器、线程池、idle主线程，并且在线程池中新增 `thread_main_ex` 线程，所有的线程都是在主核的线程池中

    其余核：执行 `cpu_run()`，通过函数调用的方式来启动协程执行器，然后 EXCUTOR 不断地查询 future 是否有进展，如果有进展，则将其从自己的任务（协程）队列中删除此任务，这个核只负责这个任务

3. 多个核之间的同步互斥

    只有两个核，一个核复制执行协程，另一个核只负责检测协程是否有进展（但是qemu 启动却用到了 4 个核）

4. 开启多核之后的变化

    - 需要维护 CPU_NUM 个 processor，每个 processor 上维护一个当前正在运行的线程
    - 线程池：封装了一个调度器，以及阻塞的线程队列
    - 调度器：每次从阻塞的线程队列中找到优先级最高的线程

5. 学长的工作的目标：让内核能够以某种方式参与协程的调度，例如，在有更高优先级的事件发生时，可以让协程让出 CPU，通过位图的方式来管理线程、协程的优先级，bitmap 并没有直接放在线程 TCB 中，而是直接放在物理内存中的固定位置，对于用户进程的 bitmap，则是预先在内存中申请 MAX_USER 个 bitmap，在运行时再分配给用户进程

     

     



### 设计目标：

最小调度单位为协程

向用户提供协程的使用接口

都支持优先级调度

协程可以强制切换和主动切换







### 文件系统与异步OS相结合

异步OS的应用场景：多个 I/O 任务和多个 CPU 计算任务

文件系统的读写：通常是先打开文件，然后读写时会将块设备中的一个或者多个块读取到内存的缓冲区，之后的读写则是对缓冲区来进行

首先内核的使用基本上已经固定了，执行系统调用之后，创建了 task 然后直接返回，之后的过程就由 EXCUTOR 不断的查询该任务是否有进展，有进展之后再回到主线程来继续执行

文件系统如何参与到这种异步的过程呢？？？

我目前想到的就是读写基于缓冲区，那么可以让缓冲区来实现某种回调的机制，来通知 EXCUTOR 唤醒特定的任务





关于异步OS的一些思考：

1. 最小的调度单位是协程：显然这是没有问题的

2. 进程、线程、协程并存：这仍然是可以的

3. 线程与协程相结合：一个线程中包含多个协程，在我看来是这个意思：一个线程有一个 executor，然后有若干个协程（future），在协程执行时，实际上就是在执行一段函数；协程执行完毕，由 executor 来调度，这个时候，如果所有的协程全部都被阻塞时，executor 在调度协程时，会检查是否出现这种情况，然后会将所属的线程阻塞，这个时候就可以调度其他的线程来执行

4. 在什么情况下会发生协程在多个线程之间调度？？？

    如果当前的线程在执行某个协程，但是并没有完成，此时不能把栈清空给下一个协程来使用，这个时候又来了另一个中断，例如该线程内的另一个协程等待的 IO 事件已经处理完毕，发出了中断请求，这时候就应该把对应的协程从线程中取出来，然后调取其他的线程来执行这个协程

5. 协程在多个线程之间调度：每个线程的 executor 都有一个协程队列，因此协程可以在线程内部进行调度，如果协程要能够在线程之间进行调度，那么则至少需要在进程或者内核当中构建一个管理者 FUTURE_MANAGER，从而使得能够在线程之间进行调度，协程在多个进程之间调度同样也是如此，虽然这样看上去简单明了，但是里面的细节还需要推敲

    1. 首先当前的线程正在执行的协程还没有结束，在执行完一条指令之后，另一个协程等待的事件完成，产生了中断，这个时候控制权到了内核，内核会进入到相应的中断处理函数

    2. 在中断处理函数中，需要完成的两件事情，首先面临的问题是找到对应的协程。例如从 stdin 读取字符，通常情况下，我们是通过线程主动发起系统调用，最终通过一个 loop 循环来等待输入字符，这个过程是同步的，因此可以直接找到对应的线程，在王文智学长的代码中，这部分是通过一个 BTreeMap 来维护读协程 id 与写协程 id 的对应关系，因此可以通过写协程来唤醒读协程，这只是一个特例，暂时跳过，就以学长的代码为例子，梳理一下整个思路

    3. 找到了对应的协程之后，首先判断正在执行的协程的状态，如果已经执行完毕，则直接调度不用切换线程；如果当前协程还没执行完毕，必须要找到另一个支持协程的线程来运行目标协程，这时候需要线程切换。王文智学长通过上述建立的对应关系，当异步写系统调用（实际上仍然是同步的过程）完成时，会唤醒对应的写协程，并更新对应的 user_bitmap，之后线程会返回到用户态，然后所属的协程执行完毕，剩下的过程就交给 EXECUTOR 调度器来调度即可

    4. 是实现一个全局的调度器还是在每个线程内部都存在一个调度器

        学长的实现方式：无论是内核还是用户态的协程都是添加在一个统一的 EXECUTOR 中，然后在此基础上来调度，所以这里也带来了一个新的问题， basic_rt 模块需要从文件系统中加载进入内核（我觉得直接在创建线程的时候就可以建立这块共享区域的地址映射，这样子应该会简单一点）；但是在我看来，应该每个线程包括一个 executor 调度器，在这个基础上来实现的话，就可以在创建线程时就将 executor、waker 等数据结构添加进线程中，但是这样子是不是会带来新的问题呢？例如切换上下文是否会增加开销？？？

    5. 关于学长代码中的线程与我想的线程

        学长的线程与正常的线程相同，只不过会在主函数中有所区别，支持协程的线程会在主函数中会绑定 EXECUTOR 来调度，正常的线程主函数则没什么区别；然而在我看来，线程应该分为两类，一类是正常的线程，另一类则是支持协程的线程，这类线程内部需要包含 executor、waker 等数据结构

    6. 关于用户态怎么能够感知到自己的 executor？？？

        一种方法就是新建一个系统调用，但是这样在用户态的协程调度又会进入到内核态，这个时候效率又会降低；

        另一种方式还是通过系统调用，直接得到对应的协程接口在线程的虚拟地址，也就是和学长的方法类似，之后就可以在主函数中创建、添加、调度协程，从而不用进入内核态，只需要在一开始执行一次系统调用即可

    7. 关于协程在不同的线程之间的调度，暂时没有什么头绪，或许可以从一些自然界中种群的分工合作现象得到答案

    8. 关于学长 EXECUTOR 全局调度器的调度策略？？？

        有一个全局的线程池 TASK_POOL，内部封装了一个 scheduler 调度器以及一个阻塞的线程集合 BTreeSet，scheduler 中维护了一个就绪线程队列，之后对线程的调度则是通过 TASK_POOL 来进行，包括更改任务的优先级；

        在 EXCUTOR 协程调度器中，封装了协程队列 task_queue、waker_cache，对于调度，只需要在 waker _cache 中唤醒协程即可，这些操作全部都是对于 tid 来进行的，因此进行优先级更新时，是对 tid 来进行的？？？







