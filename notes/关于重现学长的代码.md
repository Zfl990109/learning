### 之后会在这个文档记录，在ch8分支的基础上重现学长代码的过程

原因：选择 ch8 分支，是因为进程、线程、同步互斥以及信号量等机制已经建立好；为什么采取这种方式，我觉得能够进一步加深我的理解

### step 1：将 basic_rt 以 VSDO 的形式提供给用户进程

- 首先将 basic_rt 共享库编译成一个独立的 elf 文件，并写入文件系统
- 从文件系统中读取 basic_rt 的 elf 数据，然后映射到内核的地址空间中
- 尝试直接运行 basic_rt 的 main 函数，如果不涉及到堆的数据分配，则就是正常的函数调用，不会出现问题

##### 出现的问题

如果涉及到堆的内存分配，那么在内核 mm 模块初始化之后，跳转到 basic_rt 的 main 函数执行时，会出现错误，因为现在仍然使用的是内核的堆，但是切换到了 basic_rt 之后，申请的内存是共享库的堆，这时会产生冲突

##### 想到的解决方法

直接创建一个 basic_rt 的内核进程，创建一个全局的 EXECUTOR，直接提供相关的函数接口，之后在内核和其他进程的地址空间中加入 basic_rt 的地址空间，目前没有实现