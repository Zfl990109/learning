### 启动多核

在 Makefile 启动 qemu 中添加 -smp n 来启动 n 个核

```makefile
qemu-system-riscv64 \
		-machine virt \
		-m 128 \
		-nographic \
		-bios $(BOOTLOADER) \
		-smp 4
```

rustsbi 设置了内核的入口地址为 0x8020_0000，每个核的栈空间为 4KB，最多 8 个核

```rust
mod constants {
    /// 特权软件入口。
    pub(crate) const SUPERVISOR_ENTRY: usize = 0x8020_0000;
    /// 每个核设置 16KiB 栈空间。
    pub(crate) const LEN_STACK_PER_HART: usize = 16 * 1024;
    /// qemu-virt 最多 8 核。
    pub(crate) const NUM_HART_MAX: usize = 8;
    /// SBI 软件全部栈空间容量。
    pub(crate) const LEN_STACK_SBI: usize = LEN_STACK_PER_HART * NUM_HART_MAX;
}
```

在内核的入口处先设置 tp 寄存器、各个核使用的栈，不能直接使 sp = boot_stack_top，而是根据硬件线程 hart_id 来分配空间

```assembly
    .section .text.entry
    .globl _start
_start:
    # a0: hart id
    mv tp, a0
    la sp, boot_stack
    # li t1, 4096 * 16 # t1 = 4096 * 16 64KB
    addi t0, a0, 1  # t0 = a0 + 1 hartid+1
    slli t0, t0, 16 # 64K * (hartid + 1)
    add sp, sp, t0  # sp = sp + t0
    call rust_main

    .section .bss.stack
    .globl boot_stack
boot_stack:
    .space 4096 * 16 * 4
    .globl boot_stack_top
boot_stack_top:
```

在内核 rust_main 函数，需要根据不同的 hart_id 来完成不同的工作，同时需要对 console.rs 中的 println! 和 print! 修改，保证其执行的原子性，否则在打印时会比较混乱