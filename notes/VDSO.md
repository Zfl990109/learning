### VDSO 



用户态直接映射一段内存，把内核调用的结果保存在此处，之后用户态可以直接通过函数调用以及内存访问来降低使用系统调用的开销



**在映射共享库的虚拟地址时，需要设置写的权限，否则在初始化堆的过程中会报错**

内核的地址空间已经添加了共享库的地址映射，用户态的地址空间中添加了共享库的地址映射之后，直接跳转到共享库，却出现了 bug



重新整理一遍思路

- 先从文件系统中读取数据到 BASIC_RT_VEC，因为之后读取符号表需要查询 elf 文件，所以定义了全局数据结构

- 根据 elf 数据，构建共享库的地址空间，依次从 elf 的每个段中读取虚拟地址信息，之后构建 maparea，此时还没有复制数据，构建 maparea 之后，向 memoryset 中插入这个 maparea，并且将数据也复制到映射的物理页

- 在内核中添加这个共享库的地址映射（目前内存中已经有物理页存放了共享库的数据，因此只需要在 memoryset 的页表中添加对应的映射关系即可）

    ```rust
    pub fn add_module(&mut self, module_space: &MemorySet) {
            for area in module_space.areas.iter() {
                for vpn in area.vpn_range {
                    self.page_table.map(
                        vpn,
                        module_space.translate(vpn).unwrap().ppn(),
                        PTEFlags::R | PTEFlags::X | PTEFlags::W,
                    );
                }
            }
        }
    ```

- 在用户态进程中添加共享库的地址映射关系，在用户态进行测试时，直接通过函数调用来执行共享库代码，但是如果设计到打印信息，则会出现错误，因为打印函数是内核态的实现方式，进入了用户态之后会报错





### 目前存在的问题：

- 用户态和内核态的页面访问权限的问题，这里还需要进行细致的设计，目前只是简单的实现，将所有的进程都假设是用户进程，没有考虑到内核进程，这两者的权限会要进行考虑
- 共享库的不能够使用 println 等函数，因为是内核和用户态都要使用

