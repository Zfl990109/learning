[TOC]

### IO 模型基本概念

- 阻塞 IO：进入内核，如果没有准备好数据，则会一直等待
- 非阻塞 IO：进入内核，若内核没有准备好数据，会返回到用户态
- IO 复用模型：进程会调用 select 系统调用，监听是否有套接字获取了数据变为可读；得到对应的套接字之后，返回用户态，在获取的套接字再重新进入内核，获取数据
- 信号驱动 IO 模型：先用系统调用 sigaction 注册一个事件，返回正常的执行流，内核之后收到数据了会向进程发送一个信号，之后进程再进入内核获取数据；类似与 A 从 B的家里回去，B 让 A 到家之后给 B 打个电话（这个过程就相当于先注册一个事件），A 到家之后给 B 回了电话，B 收到之后就开始干别的事情（进程进入内核去获取数据）
- 异步 IO 模型：类似于信号驱动 IO 模型，只不过信号机制需要进入内核两次，而异步则是进入内核之后返回到正常的流程，之后数据准备好之后发送信号给用户态（用户态中断）



### 抢占式与协作式多任务

#### 抢占式的线程切换：

- 能够运行不可靠的用户态程序

- 为每个线程单独准备一个栈，避免了调用栈中的信息的保存与切换，只需要保存寄存器中的上下文
- 但是既是优点也是缺点，每个线程都必须要有自己的栈，内存开销增大，并且限制了系统的最大线程数
- 另一个缺点是 OS 必须保存完整的寄存器状态，即使任务只使用少量的寄存器

#### 协作式线程切换

- 只能运行完成或者在协作的点来主动让出 CPU，例如等待 IO 时
- 协作式任务能够和异步操作结合起来，异步操作会返回一个 not ready 状态，然后执行 yield 来让出 CPU
- 保存状态：因为任务自己定义了可以暂停的点，因此不需要操作系统来保存状态，相反，协作式线程切换能够准确的保存恢复下次执行需要的各种信息，因此这会让其性能更好，例如进行了复杂的计算之后，只需要保存计算结果，而不需要保存中间的信息
- 语言支持的协作式任务能够在暂停之前保存需要的信息，因此多个任务可以共享同一个调用栈，减少内存，理论上能够创建任意数量的协作任务
- 协作式任务的缺点：一个非协作式的任务可能会永久运行，因此必须保证所有任务都是协作式的，但是让 OS 依赖于任务的协作性，这显然是不合常理的
- 但是良好的性能以及较小的内存开销，在一个程序内使用协作式任务显然是一个好的思路，尤其是和异步操作相结合时，



### 并发的几种方式

#### 进程

缺点：地址空间隔离、切换的开销大等

#### 线程

优点：简单、易用、任务切换快

缺点：OS 级别消耗的堆栈非常大，涉及系统调用、OS 并不会很快的切换回原来的线程、某些系统不支持线程

#### GreenThread（用户态线程）

优点：切换的开销较小

缺点：栈的大小、难以跨平台

#### RUST FUTURE

##### Future ：

```rust
pub trait Future {
    type Output;
    fn poll(self: Pin<&mut Self>, cx: &mut Context) -> Poll<Self::Output>;
}

pub enum Poll<T> {
    Ready(T),
    Pending,
}
```

then、map 等 combinator methods 会让编程变得很复杂，因为会发生所有权的转移以及生命周期不同等问题，而 async/await 则让代码看起来像同步的代码

状态机转换：并不是 wait 与 wait 之间可以暂停，而是整个 wait 是一个暂停点，在这个过程中，可以把 CPU 让出来

保存状态：不需要保存在 wait 时的所有状态，因为它知道下一个过程需要的所有数据，因此可以定制保存信息的数据结构

每个阶段都会根据 .await 前后所需要的信息来定制上下文数据结构，状态划分是根据 .await 来进行，在 .await 出时会完成一个状态转换的过程（*self = ......）

```rust
ExampleStateMachine::Start(state) => {
    // from body of `example`
    let foo_txt_future = async_read_file("foo.txt");
    // `.await` operation
    let state = WaitingOnFooTxtState {
        min_len: state.min_len,
        foo_txt_future,
    };
    *self = ExampleStateMachine::WaitingOnFooTxt(state);
}
```

完成状态转换之后，通过最外层的 loop 循环，就可以推进到另一个状态

```rust
impl Future for ExampleStateMachine {
    type Output = String; // return type of `example`

    fn poll(self: Pin<&mut Self>, cx: &mut Context) -> Poll<Self::Output> {
        loop {
            match self { // TODO: handle pinning
                ExampleStateMachine::Start(state) => {…}
                ExampleStateMachine::WaitingOnFooTxt(state) => {…}
                ExampleStateMachine::WaitingOnBarTxt(state) => {…}
                ExampleStateMachine::End(state) => {…}
            }
        }
    }
}
```

##### 如何解决自引用结构移动的问题

1. 在移动之后，更新自引用结构中的指针，但是会对性能造成较大的影响，因为需要对所有的数据域进行检查
2. 不再存放指针，而是指针指向的数据在子引用结构中的偏移
3. 禁止移动自引用结构，不用再额外增加 runtime 开销，将处理的负担转移给写出自引用结构的程序员

> 虽然是禁止了，但是可以通过在堆上创建自引用结构，通过 Box 包装起来使用，尽管指针会改变，但是堆上分配的自引用结构的位置却不会移动，但是还是有可能会破坏这个自引用结构，例如 mm::replacce 会将原来的自引用结构移动到栈上去，返回一个 &mut 的数据结构，但是这个结构里面的 self_ptr 仍然指向原来的位置，因此仅仅在堆上分配仍然不能够保证安全的使用自引用结构
>
> 因为还存在上述问题，因此在 Box 外层再封装一个 Pin，需要在自引用结构内部增加一个标记类型，并且在申请数据实例时使用 Box::pin() 方法，虽然这样子禁止了获取 &mut 的可能，但是这样也禁止了申请实例之后的初始化，只能通过 unsafe、as_mut、get_unchecked_mut 来进行初始化，例如
>
> ```rust
> unsafe {
>  let mut_ref = Pin::as_mut(&mut heap_value);
>  Pin::get_unchecked_mut(mut_ref).self_ptr = ptr;
> }
> ```
>
> 虽然上述操作让我们能够安全的使用自引用结构，但是在堆上分配内存会对性能造成一定的影响，而且因此有探索出了在栈上分配的 Pin<&mut T> 方法，它只是暂时的借用包装的值，而不是真的拥有所有权，但是这需要程序员来确保其安全性，调用者必须将 Future 包装在首位来保证在内存中不会移动，因此还是使用上述方法，在堆上分配

##### 怎么来执行 Future？

之前的 async、await 等过程只是编译器创建好了状态机，但是实际上还是没有运行，只有在被 poll 的时候才会执行，必须要在某个地方调用。

- 可以手动的使用 loop 来循环的调用，但是这非常低效，并且在创建了大量的 Future 时不实用，因此需要定义一个全局的 executor 来负责 poll 所有的 Future，这样可以让 executor 来选择切换 Future，因此就可以执行异步操作，轮询则只能顺序执行，不能够灵活处理
- executor 会创建 waker，让 waker 在任务完成时能够释放信号，从而 executor 不必一直轮询，在这个过程实际上就是让当前的 executor 睡眠，然后下一次发生中断，表示事件已经完成，同时也可以通过中断来唤醒 executor 来执行，实际上就是在 loop 中加入了 sleep



### 异步的几种方法

- 信号机制（用户态的异步处理机制）：通过 sigaction 系统调用注册某个信号，之后会返回到用户态正常的执行流，之后若有其他的进程等向当前的进程发送了一个信号，则当下一次进程进入到内核并返回时，会进入到预先设定好的用户态中断处理函数中，在用户态中断处理函数结束会发送一个信号，让进程从内核返回时回到正常的执行流

- 基于回调的方法：传递需要执行的函数指针，主函数传递回调函数的函数指针，在主函数中先执行回调函数，再执行主函数，但是主函数和回调函数是一个并行的过程，并不会因为回调函数阻塞而阻塞
    - 优点：容易实现、没有上下文的切换、相对较低的内存开销
    - 缺点：随着回调函数数量的增加，内存开销成线性增长、回调函数会对正常的执行流中的信息进行更改，这个是不符合逻辑的，也是难以预测的，难以找到 bug
- Event queue：Epoll，Kqueue and IOCP
    - Epoll：在发生大量的事件时非常高效，epoll_create() 会在内核创建一个 epoll 实例，通过 epoll_ctl() 注册事件，通过 epoll_wait() 返回就绪的事件和数据（子集），线程注册事件之后就返回用户态，之后继续执行，等到等待的事件执行完，会发送信号给用户态线程
- io_uring：设置了共享缓冲区，减少了不必要的数据传递
    - io_uring_setup：设置上下文
    - io_uring_enter：提交并获取完成的任务
    - io_uring_register：注册内核用户共享的缓冲区



### 关于 RUST FUTURE 的一些思考

- 编译器只是根据 .await 将一个函数转换为一个状态机，如何与异步操作相结合起来，则是取决于 Executor 的实现？？？
- 如何实现协程的调度呢？？？是在 Executor 中定义的 run 方法中实现的策略吗？？？怎么让内核参与到调度呢？？？
